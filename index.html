<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galvo Fibre Laser Angle Calculator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        /* animated background particles */
        body::before {
            content: '';
            position: fixed;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: 
                radial-gradient(circle, rgba(138, 43, 226, 0.1) 1px, transparent 1px),
                radial-gradient(circle, rgba(0, 188, 212, 0.1) 1px, transparent 1px);
            background-size: 50px 50px, 80px 80px;
            background-position: 0 0, 40px 40px;
            animation: drift 20s linear infinite;
            z-index: -1;
        }

        @keyframes drift {
            from {
                transform: rotate(0deg) scale(1.5);
            }
            to {
                transform: rotate(360deg) scale(1.5);
            }
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .container {
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 24px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 120px rgba(138, 43, 226, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            padding: 45px;
            max-width: 650px;
            width: 100%;
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 10;
        }

        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(138, 43, 226, 0.6), 
                rgba(0, 188, 212, 0.6),
                transparent);
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% {
                opacity: 0.3;
            }
            50% {
                opacity: 1;
            }
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            text-align: centre;
            font-size: 32px;
            font-weight: 700;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, #fff 0%, #8a2be2 50%, #00bcd4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(138, 43, 226, 0.5);
        }

        h2 {
            color: #00bcd4;
            margin-bottom: 20px;
            font-size: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: centre;
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.5);
            text-align: centre;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 500;
        }

        .interaction-hint {
            text-align: centre;
            margin: 0 auto 25px auto;
            padding: 8px 16px;
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 20px;
            display: table;
            animation: pulse-hint 3s ease-in-out infinite;
        }
        
        @keyframes pulse-hint {
            0%, 100% {
                opacity: 0.6;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.02);
            }
        }

        .interaction-hint span {
            color: rgba(138, 43, 226, 0.8);
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .input-group {
            margin-bottom: 28px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        input[type="number"], select {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid rgba(138, 43, 226, 0.2);
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            backdrop-filter: blur(10px);
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #8a2be2;
            background: rgba(138, 43, 226, 0.1);
            box-shadow: 
                0 0 0 3px rgba(138, 43, 226, 0.1),
                0 0 20px rgba(138, 43, 226, 0.2);
            transform: translateY(-2px);
        }

        input[type="number"]:hover, select:hover {
            border-color: rgba(138, 43, 226, 0.4);
            background: rgba(255, 255, 255, 0.08);
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .unit {
            position: absolute;
            right: 16px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            pointer-events: none;
            font-weight: 600;
        }

        input[type="number"] {
            padding-right: 50px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }

        .preset-btn {
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(138, 43, 226, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .preset-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(138, 43, 226, 0.6);
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
        }

        .preset-btn:hover {
            border-color: #8a2be2;
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(138, 43, 226, 0.3);
        }

        .preset-btn:hover::before {
            width: 100px;
            height: 100px;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            border-color: transparent;
            color: #fff;
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
            transform: translateY(-2px);
        }

        .preset-btn.active::before {
            display: none;
        }

        .calculate-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 25px;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        .calculate-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .calculate-btn:hover::before {
            left: 100%;
        }

        .calculate-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(138, 43, 226, 0.4);
        }

        .calculate-btn:active {
            transform: translateY(-1px);
        }

        .results {
            margin-top: 35px;
            padding: 30px;
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 16px;
            display: none;
            position: relative;
            overflow: hidden;
        }

        .results::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .results.show {
            display: block;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 0;
            border-bottom: 1px solid rgba(138, 43, 226, 0.2);
            position: relative;
            z-index: 1;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .result-value {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
        }

        .result-value.highlight {
            font-size: 28px;
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% {
                filter: drop-shadow(0 0 5px rgba(138, 43, 226, 0.5));
            }
            50% {
                filter: drop-shadow(0 0 20px rgba(138, 43, 226, 0.8));
            }
        }

        .diagram {
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 12px;
            text-align: centre;
            position: relative;
            z-index: 1;
        }

        .cut-section {
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 12px;
            position: relative;
            z-index: 1;
        }

        .cut-section h3 {
            color: #00bcd4;
            font-size: 16px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: centre;
        }

        .material-controls {
            margin-bottom: 15px;
            text-align: centre;
        }

        .material-controls label {
            display: block;
            margin-bottom: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
        }

        .thickness-buttons {
            display: flex;
            justify-content: centre;
            gap: 8px;
            flex-wrap: wrap;
        }

        .thickness-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(138, 43, 226, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
        }

        .thickness-btn:hover {
            border-color: #00bcd4;
            color: #fff;
            background: rgba(0, 188, 212, 0.1);
        }

        .thickness-btn.active {
            background: linear-gradient(135deg, #00bcd4 0%, #0097a7 100%);
            border-color: transparent;
            color: #fff;
        }

        .cut-measurements {
            margin-top: 15px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .measurement {
            padding: 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            border: 1px solid rgba(138, 43, 226, 0.1);
        }

        .measurement-label {
            display: block;
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .measurement-value {
            display: block;
            color: #fff;
            font-size: 16px;
            font-weight: 700;
        }

        #cutQuality {
            color: #4caf50;
        }

        .calculation-note {
            margin-top: 15px;
            text-align: centre;
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            font-style: italic;
        }

        /* Tab navigation styles */
        .tab-navigation {
            display: flex;
            gap: 5px;
            margin-bottom: 25px;
            border-bottom: 2px solid rgba(138, 43, 226, 0.2);
            padding-bottom: 0;
        }

        .tab-btn {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-top: 2px solid transparent;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
        }

        .tab-btn:hover {
            color: rgba(255, 255, 255, 0.8);
            background: rgba(138, 43, 226, 0.1);
        }

        .tab-btn.active {
            color: #00bcd4;
            border-top-color: #00bcd4;
            background: rgba(0, 188, 212, 0.1);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .result-card, .property-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 8px;
            padding: 15px;
        }

        .result-card h3, .property-card h3 {
            color: #00bcd4;
            font-size: 14px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric {
            margin-bottom: 10px;
        }

        .metric-label {
            display: block;
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            margin-bottom: 3px;
        }

        .metric-value {
            display: block;
            color: #fff;
            font-size: 18px;
            font-weight: 700;
        }

        .metric-value.highlight {
            color: #8a2be2;
        }

        /* Material tab styles */
        .material-selector {
            margin-bottom: 25px;
        }

        .material-properties {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        /* Tools tab styles */
        canvas {
            max-width: 100%;
            height: auto;
        }

        .info-box {
            margin-top: 25px;
            padding: 18px;
            background: rgba(255, 152, 0, 0.1);
            border-left: 4px solid #ff9800;
            border-radius: 8px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            position: relative;
            z-index: 1;
            backdrop-filter: blur(5px);
        }

        .info-box strong {
            color: #ff9800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider-container {
            margin-top: 15px;
        }

        input[type="range"] {
            width: 100%;
            margin-top: 12px;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
            transition: all 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
            transition: all 0.3s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
        }

        .slider-value {
            text-align: centre;
            margin-top: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
        }

        /* smooth transitions for all interactive elements */
        * {
            transition: color 0.3s, background-color 0.3s, border-color 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>
    <div class="container">
        <h1>Galvo Fibre Laser Angle Calculator</h1>
        <p class="subtitle">professional laser cutting parameter calculator</p>
        <div class="interaction-hint">
            <span>ðŸŽ® Click background for lasers â€¢ Press [Space] for burst â€¢ Press [P] for particles</span>
        </div>

        <div class="tab-navigation">
            <button class="tab-btn active" onclick="switchTab('basic')">Basic Calculator</button>
            <button class="tab-btn" onclick="switchTab('materials')">Materials</button>
        </div>

        <div id="basic-tab" class="tab-content active">

        <div class="input-group">
            <label for="focalLength">Lens Focal Length</label>
            <div class="input-wrapper">
                <input type="number" id="focalLength" value="160" min="50" max="1000" step="1" oninput="calculate()">
                <span class="unit">mm</span>
            </div>
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setFocalLength(50)">50mm</button>
                <button class="preset-btn" onclick="setFocalLength(100)">100mm</button>
                <button class="preset-btn active" onclick="setFocalLength(160)">160mm</button>
                <button class="preset-btn" onclick="setFocalLength(175)">175mm</button>
                <button class="preset-btn" onclick="setFocalLength(254)">254mm</button>
                <button class="preset-btn" onclick="setFocalLength(330)">330mm</button>
                <button class="preset-btn" onclick="setFocalLength(420)">420mm</button>
            </div>
        </div>

        <div class="input-group">
            <label for="inputType">Specify Position By</label>
            <select id="inputType" onchange="toggleInputType()">
                <option value="distance">distance from centre</option>
                <option value="field">total field size</option>
                <option value="coordinates">x,y coordinates</option>
            </select>
        </div>

        <div id="distanceInput" class="input-group">
            <label for="distance">Distance from Centre</label>
            <div class="input-wrapper">
                <input type="number" id="distance" value="50" min="0" max="500" step="0.1" oninput="calculate()">
                <span class="unit">mm</span>
            </div>
        </div>

        <div id="fieldInput" class="input-group" style="display: none;">
            <label for="fieldSize">Total Field Size (Square)</label>
            <div class="input-wrapper">
                <input type="number" id="fieldSize" value="110" min="0" max="1000" step="1" oninput="calculate()">
                <span class="unit">mm</span>
            </div>
            <div class="slider-container">
                <label for="positionSlider">Position within Field (0% = centre, 100% = edge)</label>
                <input type="range" id="positionSlider" min="0" max="100" value="50" oninput="updateSliderValue(); calculate()">
                <div class="slider-value">Position: <span id="sliderValue">50</span>%</div>
            </div>
        </div>

        <div id="coordinateInput" class="input-group" style="display: none;">
            <label>Position Coordinates</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <div class="input-wrapper">
                    <input type="number" id="xCoord" value="30" min="-500" max="500" step="0.1" placeholder="X" oninput="calculate()">
                    <span class="unit">mm</span>
                </div>
                <div class="input-wrapper">
                    <input type="number" id="yCoord" value="40" min="-500" max="500" step="0.1" placeholder="Y" oninput="calculate()">
                    <span class="unit">mm</span>
                </div>
            </div>
        </div>

        <button class="calculate-btn" onclick="calculate()" style="display: none;">Recalculate</button>

        <div id="results" class="results">
            <div class="result-item">
                <span class="result-label">Beam Incidence Angle</span>
                <span class="result-value highlight" id="angleResult">0Â°</span>
            </div>
            <div class="result-item">
                <span class="result-label">Angle (radians)</span>
                <span class="result-value" id="angleRadians">0 rad</span>
            </div>
            <div class="result-item">
                <span class="result-label">Deviation from Perpendicular</span>
                <span class="result-value" id="deviation">0Â°</span>
            </div>
            <div class="result-item">
                <span class="result-label">Actual Distance from Centre</span>
                <span class="result-value" id="actualDistance">0 mm</span>
            </div>
            <div class="result-item">
                <span class="result-label">Maximum Field Size (theoretical)</span>
                <span class="result-value" id="maxField">0 mm</span>
            </div>
            
            <div class="diagram">
                <canvas id="diagram" width="400" height="300"></canvas>
            </div>
            
            <div class="cut-section">
                <h3>Material Cut Cross-Section</h3>
                <div class="material-controls">
                    <label for="materialThickness">Material Thickness</label>
                    <div class="thickness-buttons">
                        <button class="thickness-btn active" onclick="setThickness(1)">1mm</button>
                        <button class="thickness-btn" onclick="setThickness(3)">3mm</button>
                        <button class="thickness-btn" onclick="setThickness(6)">6mm</button>
                        <button class="thickness-btn" onclick="setThickness(10)">10mm</button>
                        <button class="thickness-btn" onclick="setThickness(15)">15mm</button>
                    </div>
                </div>
                <canvas id="cutDiagram" width="400" height="250"></canvas>
                <div class="cut-measurements">
                    <div class="measurement">
                        <span class="measurement-label">Top Kerf Width:</span>
                        <span class="measurement-value" id="topKerf">0.00 mm</span>
                    </div>
                    <div class="measurement">
                        <span class="measurement-label">Bottom Kerf Width:</span>
                        <span class="measurement-value" id="bottomKerf">0.00 mm</span>
                    </div>
                    <div class="measurement">
                        <span class="measurement-label">Cut Taper Angle:</span>
                        <span class="measurement-value" id="taperAngle">0.0Â°</span>
                    </div>
                    <div class="measurement">
                        <span class="measurement-label">Cut Quality:</span>
                        <span class="measurement-value" id="cutQuality">Excellent</span>
                    </div>
                </div>
                <div class="calculation-note">
                    <small>calculations based on: 0.15mm spot size, 3mrad beam divergence (typical fiber laser)</small>
                </div>
            </div>

            <div class="info-box">
                <strong>note:</strong> the angle shown is the beam incidence angle relative to the perpendicular (normal) to the work surface. larger angles result in reduced cutting efficiency and potential quality issues. typical acceptable angles are below 15-20Â° for most applications.
            </div>
        </div>
        </div> <!-- end basic-tab -->

        <div id="materials-tab" class="tab-content">
            <h2>Material Database</h2>
            
            <div class="material-selector">
                <label for="materialType">Select Material</label>
                <select id="materialType" onchange="loadMaterialProperties()">
                    <option value="mild-steel">Mild Steel</option>
                    <option value="stainless">Stainless Steel</option>
                    <option value="aluminium">Aluminium</option>
                    <option value="brass">Brass</option>
                    <option value="copper">Copper</option>
                    <option value="titanium">Titanium</option>
                    <option value="acrylic">Acrylic</option>
                    <option value="wood">Wood</option>
                    <option value="abs">ABS Plastic</option>
                    <option value="carbon-fiber">Carbon Fibre</option>
                </select>
            </div>
            
            <div class="material-properties">
                <div class="property-card">
                    <h3>Optical Properties</h3>
                    <div class="metric">
                        <span class="metric-label">Absorption @ 1070nm:</span>
                        <span class="metric-value" id="absorption">0%</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Reflectivity:</span>
                        <span class="metric-value" id="reflectivity">0%</span>
                    </div>
                </div>
                
                <div class="property-card">
                    <h3>Recommended Parameters</h3>
                    <div class="metric">
                        <span class="metric-label">Power Range:</span>
                        <span class="metric-value" id="powerRange">0-0 W</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Speed Range:</span>
                        <span class="metric-value" id="speedRange">0-0 mm/s</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Max Angle:</span>
                        <span class="metric-value" id="maxAngle">0Â°</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Assist Gas:</span>
                        <span class="metric-value" id="assistGas">None</span>
                    </div>
                </div>
            </div>
        </div>

        
    </div> <!-- end container -->

    <script>
        function setFocalLength(value) {
            document.getElementById('focalLength').value = value;
            
            // update active button state
            const buttons = document.querySelectorAll('.preset-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === value + 'mm') {
                    btn.classList.add('active');
                }
            });
            
            // trigger calculation with new focal length
            calculate();
        }

        function toggleInputType() {
            const inputType = document.getElementById('inputType').value;
            const distanceInput = document.getElementById('distanceInput');
            const fieldInput = document.getElementById('fieldInput');
            const coordinateInput = document.getElementById('coordinateInput');
            
            distanceInput.style.display = inputType === 'distance' ? 'block' : 'none';
            fieldInput.style.display = inputType === 'field' ? 'block' : 'none';
            coordinateInput.style.display = inputType === 'coordinates' ? 'block' : 'none';
            
            // recalculate with the new input type
            calculate();
        }

        function updateSliderValue() {
            const slider = document.getElementById('positionSlider');
            document.getElementById('sliderValue').textContent = slider.value;
        }

        function calculate() {
            const focalLength = parseFloat(document.getElementById('focalLength').value);
            const inputType = document.getElementById('inputType').value;
            
            let distanceFromCentre;
            
            if (inputType === 'distance') {
                distanceFromCentre = parseFloat(document.getElementById('distance').value);
            } else if (inputType === 'field') {
                const fieldSize = parseFloat(document.getElementById('fieldSize').value);
                const position = parseFloat(document.getElementById('positionSlider').value) / 100;
                distanceFromCentre = (fieldSize / 2) * position;
            } else if (inputType === 'coordinates') {
                const x = parseFloat(document.getElementById('xCoord').value);
                const y = parseFloat(document.getElementById('yCoord').value);
                distanceFromCentre = Math.sqrt(x * x + y * y);
            }
            
            // calculate angle using arctangent
            // angle = arctan(distance_from_centre / focal_length)
            const angleRadians = Math.atan(distanceFromCentre / focalLength);
            const angleDegrees = angleRadians * (180 / Math.PI);
            
            // calculate theoretical maximum field size (typically limited to about 70% for quality)
            const maxFieldTheoretical = focalLength * 2 * Math.tan(70 * Math.PI / 180);
            
            // display results
            document.getElementById('angleResult').textContent = angleDegrees.toFixed(2) + 'Â°';
            document.getElementById('angleRadians').textContent = angleRadians.toFixed(4) + ' rad';
            document.getElementById('deviation').textContent = angleDegrees.toFixed(2) + 'Â°';
            document.getElementById('actualDistance').textContent = distanceFromCentre.toFixed(1) + ' mm';
            document.getElementById('maxField').textContent = maxFieldTheoretical.toFixed(0) + ' mm';
            
            // show results section
            document.getElementById('results').classList.add('show');
            
            // draw diagram
            drawDiagram(focalLength, distanceFromCentre, angleDegrees);
            
            // draw cut section
            drawCutSection(angleDegrees, currentThickness);
        }

        // animation state for diagram laser
        let diagramAnimationFrame = 0;
        let diagramAnimationId = null;
        let currentThickness = 1; // default thickness in mm
        
        function setThickness(thickness) {
            currentThickness = thickness;
            
            // update active button
            const buttons = document.querySelectorAll('.thickness-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === thickness + 'mm') {
                    btn.classList.add('active');
                }
            });
            
            // recalculate and redraw
            calculate();
        }
        
        function drawCutSection(angle, thickness) {
            const canvas = document.getElementById('cutDiagram');
            const ctx = canvas.getContext('2d');
            
            // clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const topY = 50;
            const scale = Math.min(150 / thickness, 10); // scale based on thickness
            const materialHeight = thickness * scale;
            const bottomY = topY + materialHeight;
            
            // calculate kerf widths based on angle
            // typical spot size 0.05-0.15mm for fibre lasers
            const spotSize = 0.08; // mm at focus (80 microns - typical for fibre laser)
            const beamDivergence = 0.002; // 2 milliradians typical for fibre laser
            
            // top kerf is the spot size projected at angle
            // when cutting at an angle, the circular spot becomes elliptical
            const topKerfWidth = spotSize / Math.cos(angle * Math.PI / 180);
            
            // calculate actual path length through material at angle
            const pathLength = thickness / Math.cos(angle * Math.PI / 180);
            
            // beam diverges as it travels through material
            // divergence effect = path_length * tan(divergence_angle)
            const beamExpansion = pathLength * Math.tan(beamDivergence);
            
            // bottom kerf is top kerf plus the beam expansion on both sides
            const bottomKerfWidth = topKerfWidth + (beamExpansion * 2);
            
            // add small thermal effect (material melts slightly beyond beam)
            const thermalEffect = 0.01; // 10 microns thermal spread
            const finalTopKerf = topKerfWidth + thermalEffect;
            const finalBottomKerf = bottomKerfWidth + thermalEffect;
            
            // scale for drawing (exaggerate for visibility)
            const maxKerf = Math.max(finalTopKerf, finalBottomKerf);
            const drawScale = Math.min(100, 30 / maxKerf); // scale to make visible but reasonable
            const topKerfPixels = finalTopKerf * drawScale;
            const bottomKerfPixels = finalBottomKerf * drawScale;
            
            // draw material blocks (left and right of cut)
            const gradient = ctx.createLinearGradient(0, topY, 0, bottomY);
            gradient.addColorStop(0, 'rgba(100, 100, 120, 1)');
            gradient.addColorStop(0.5, 'rgba(80, 80, 100, 1)');
            gradient.addColorStop(1, 'rgba(60, 60, 80, 1)');
            
            // left material block
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(20, topY);
            ctx.lineTo(centerX - topKerfPixels/2, topY);
            ctx.lineTo(centerX - bottomKerfPixels/2, bottomY);
            ctx.lineTo(20, bottomY);
            ctx.closePath();
            ctx.fill();
            
            // right material block
            ctx.beginPath();
            ctx.moveTo(centerX + topKerfPixels/2, topY);
            ctx.lineTo(canvas.width - 20, topY);
            ctx.lineTo(canvas.width - 20, bottomY);
            ctx.lineTo(centerX + bottomKerfPixels/2, bottomY);
            ctx.closePath();
            ctx.fill();
            
            // draw cut edges with heat affected zone
            const hazGradientLeft = ctx.createLinearGradient(
                centerX - topKerfPixels/2 - 10, topY,
                centerX - topKerfPixels/2, topY
            );
            hazGradientLeft.addColorStop(0, 'transparent');
            hazGradientLeft.addColorStop(0.5, 'rgba(255, 100, 0, 0.3)');
            hazGradientLeft.addColorStop(1, 'rgba(255, 200, 0, 0.6)');
            
            const hazGradientRight = ctx.createLinearGradient(
                centerX + topKerfPixels/2, topY,
                centerX + topKerfPixels/2 + 10, topY
            );
            hazGradientRight.addColorStop(0, 'rgba(255, 200, 0, 0.6)');
            hazGradientRight.addColorStop(0.5, 'rgba(255, 100, 0, 0.3)');
            hazGradientRight.addColorStop(1, 'transparent');
            
            // left HAZ
            ctx.fillStyle = hazGradientLeft;
            ctx.beginPath();
            ctx.moveTo(centerX - topKerfPixels/2 - 10, topY);
            ctx.lineTo(centerX - topKerfPixels/2, topY);
            ctx.lineTo(centerX - bottomKerfPixels/2, bottomY);
            ctx.lineTo(centerX - bottomKerfPixels/2 - 10, bottomY);
            ctx.closePath();
            ctx.fill();
            
            // right HAZ
            ctx.fillStyle = hazGradientRight;
            ctx.beginPath();
            ctx.moveTo(centerX + topKerfPixels/2, topY);
            ctx.lineTo(centerX + topKerfPixels/2 + 10, topY);
            ctx.lineTo(centerX + bottomKerfPixels/2 + 10, bottomY);
            ctx.lineTo(centerX + bottomKerfPixels/2, bottomY);
            ctx.closePath();
            ctx.fill();
            
            // draw laser beam through the cut
            const beamAngleRad = angle * Math.PI / 180;
            const beamStartX = centerX - Math.sin(beamAngleRad) * 50;
            const beamStartY = topY - Math.cos(beamAngleRad) * 50;
            const beamEndX = centerX + Math.sin(beamAngleRad) * 50;
            const beamEndY = bottomY + Math.cos(beamAngleRad) * 50;
            
            // beam glow
            ctx.strokeStyle = 'rgba(255, 0, 100, 0.2)';
            ctx.lineWidth = 20;
            ctx.beginPath();
            ctx.moveTo(beamStartX, beamStartY);
            ctx.lineTo(beamEndX, beamEndY);
            ctx.stroke();
            
            // beam core
            const beamGradient = ctx.createLinearGradient(beamStartX, beamStartY, beamEndX, beamEndY);
            beamGradient.addColorStop(0, 'rgba(255, 100, 200, 0.8)');
            beamGradient.addColorStop(0.5, 'rgba(255, 0, 100, 1)');
            beamGradient.addColorStop(1, 'rgba(255, 100, 0, 0.8)');
            ctx.strokeStyle = beamGradient;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(beamStartX, beamStartY);
            ctx.lineTo(beamEndX, beamEndY);
            ctx.stroke();
            
            // draw surface texture/striations on cut edges
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 20; i++) {
                const y = topY + (i * materialHeight / 20);
                // left edge striations
                ctx.beginPath();
                ctx.moveTo(centerX - topKerfPixels/2 - (bottomKerfPixels - topKerfPixels) * i / 40, y);
                ctx.lineTo(centerX - topKerfPixels/2 - (bottomKerfPixels - topKerfPixels) * i / 40 - 5, y);
                ctx.stroke();
                // right edge striations
                ctx.beginPath();
                ctx.moveTo(centerX + topKerfPixels/2 + (bottomKerfPixels - topKerfPixels) * i / 40, y);
                ctx.lineTo(centerX + topKerfPixels/2 + (bottomKerfPixels - topKerfPixels) * i / 40 + 5, y);
                ctx.stroke();
            }
            
            // draw dimension lines
            ctx.strokeStyle = 'rgba(0, 188, 212, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            
            // top kerf width dimension
            ctx.beginPath();
            ctx.moveTo(centerX - topKerfPixels/2, topY - 10);
            ctx.lineTo(centerX + topKerfPixels/2, topY - 10);
            ctx.stroke();
            
            // vertical lines for top dimension
            ctx.beginPath();
            ctx.moveTo(centerX - topKerfPixels/2, topY - 15);
            ctx.lineTo(centerX - topKerfPixels/2, topY - 5);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX + topKerfPixels/2, topY - 15);
            ctx.lineTo(centerX + topKerfPixels/2, topY - 5);
            ctx.stroke();
            
            // bottom kerf width dimension
            ctx.beginPath();
            ctx.moveTo(centerX - bottomKerfPixels/2, bottomY + 10);
            ctx.lineTo(centerX + bottomKerfPixels/2, bottomY + 10);
            ctx.stroke();
            
            // vertical lines for bottom dimension
            ctx.beginPath();
            ctx.moveTo(centerX - bottomKerfPixels/2, bottomY + 5);
            ctx.lineTo(centerX - bottomKerfPixels/2, bottomY + 15);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX + bottomKerfPixels/2, bottomY + 5);
            ctx.lineTo(centerX + bottomKerfPixels/2, bottomY + 15);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'centre';
            ctx.fillText('TOP', centerX, topY - 20);
            ctx.fillText('BOTTOM', centerX, bottomY + 25);
            
            // material thickness label
            ctx.save();
            ctx.translate(15, topY + materialHeight/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(thickness + ' mm', 0, 0);
            ctx.restore();
            
            // angle indicator
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(centerX, topY - 40);
            ctx.lineTo(centerX, bottomY + 40);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // draw angle arc
            if (angle > 0) {
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, topY - 30, 20, Math.PI/2 - beamAngleRad, Math.PI/2);
                ctx.stroke();
                
                ctx.fillStyle = '#8a2be2';
                ctx.font = 'bold 11px Arial';
                ctx.fillText(angle.toFixed(1) + 'Â°', centerX + 30, topY - 25);
            }
            
            // update measurements
            document.getElementById('topKerf').textContent = finalTopKerf.toFixed(3) + ' mm';
            document.getElementById('bottomKerf').textContent = finalBottomKerf.toFixed(3) + ' mm';
            
            // taper angle is half the difference in kerf widths over the thickness
            // this creates the V-shaped cut profile
            const taperAngleDeg = Math.atan((finalBottomKerf - finalTopKerf) / (2 * thickness)) * 180 / Math.PI;
            document.getElementById('taperAngle').textContent = taperAngleDeg.toFixed(2) + 'Â°';
            
            // determine cut quality based on angle
            let quality = 'Excellent';
            let qualityColor = '#4caf50';
            if (angle > 20) {
                quality = 'Poor';
                qualityColor = '#f44336';
            } else if (angle > 15) {
                quality = 'Acceptable';
                qualityColor = '#ff9800';
            } else if (angle > 10) {
                quality = 'Good';
                qualityColor = '#ffc107';
            } else if (angle > 5) {
                quality = 'Very Good';
                qualityColor = '#8bc34a';
            }
            
            const qualityElement = document.getElementById('cutQuality');
            qualityElement.textContent = quality;
            qualityElement.style.color = qualityColor;
            
            // add quality indicator bar
            ctx.fillStyle = qualityColor;
            ctx.fillRect(canvas.width - 15, topY, 5, materialHeight);
            
            // magnification indicator
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('Ã—' + scale.toFixed(0) + ' magnification', canvas.width - 20, canvas.height - 10);
        }
        
        function drawDiagram(focalLength, distance, angle) {
            const canvas = document.getElementById('diagram');
            const ctx = canvas.getContext('2d');
            
            // cancel previous animation if running
            if (diagramAnimationId) {
                cancelAnimationFrame(diagramAnimationId);
            }
            
            const centerX = canvas.width / 2;
            const centerY = 50;
            const scale = Math.min(200 / focalLength, 2);
            const workY = centerY + focalLength * scale;
            const targetX = centerX + distance * scale;
            
            // reset animation frame
            diagramAnimationFrame = 0;
            
            function animateDiagram() {
                // clear canvas
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // draw glow effect for lens
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 30);
                gradient.addColorStop(0, 'rgba(138, 43, 226, 0.3)');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // draw lens with pulsing effect
                const lensPulse = Math.sin(diagramAnimationFrame * 0.05) * 2 + 20;
                ctx.strokeStyle = '#8a2be2';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, lensPulse, 0, Math.PI * 2);
                ctx.stroke();
                
                // lens highlight
                ctx.strokeStyle = '#00bcd4';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, lensPulse + 2, -Math.PI / 4, Math.PI / 4);
                ctx.stroke();
                
                ctx.fillStyle = '#8a2be2';
                ctx.font = '12px Arial';
                ctx.fillText('lens', centerX - 15, centerY - 25);
                
                // draw work surface with glow
                ctx.shadowColor = 'rgba(0, 188, 212, 0.5)';
                ctx.shadowBlur = 10;
                ctx.strokeStyle = '#00bcd4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(30, workY);
                ctx.lineTo(canvas.width - 30, workY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#00bcd4';
                ctx.font = '12px Arial';
                ctx.fillText('work surface', 30, workY + 20);
                
                // calculate laser beam animation progress (0 to 1, then reset)
                const beamCycle = 150; // frames for one complete beam
                const beamProgress = (diagramAnimationFrame % beamCycle) / beamCycle;
                
                // draw animated laser beam
                if (beamProgress < 0.8) { // beam firing phase (80% of cycle)
                    const currentProgress = beamProgress / 0.8; // normalise to 0-1
                    
                    // calculate current beam endpoint
                    const currentEndX = centerX + (targetX - centerX) * currentProgress;
                    const currentEndY = centerY + (workY - centerY) * currentProgress;
                    
                    // draw laser beam trail with fading effect
                    for (let i = 0; i < 5; i++) {
                        const trailProgress = Math.max(0, currentProgress - i * 0.02);
                        if (trailProgress > 0) {
                            const trailEndX = centerX + (targetX - centerX) * trailProgress;
                            const trailEndY = centerY + (workY - centerY) * trailProgress;
                            const trailStartProgress = Math.max(0, trailProgress - 0.1);
                            const trailStartX = centerX + (targetX - centerX) * trailStartProgress;
                            const trailStartY = centerY + (workY - centerY) * trailStartProgress;
                            
                            ctx.strokeStyle = `rgba(255, 0, 100, ${0.2 - i * 0.03})`;
                            ctx.lineWidth = 8 - i;
                            ctx.beginPath();
                            ctx.moveTo(trailStartX, trailStartY);
                            ctx.lineTo(trailEndX, trailEndY);
                            ctx.stroke();
                        }
                    }
                    
                    // draw main laser beam with gradient
                    const beamStartProgress = Math.max(0, currentProgress - 0.1);
                    const beamStartX = centerX + (targetX - centerX) * beamStartProgress;
                    const beamStartY = centerY + (workY - centerY) * beamStartProgress;
                    
                    const beamGradient = ctx.createLinearGradient(beamStartX, beamStartY, currentEndX, currentEndY);
                    beamGradient.addColorStop(0, 'rgba(255, 100, 200, 0.2)');
                    beamGradient.addColorStop(0.5, 'rgba(255, 0, 100, 1)');
                    beamGradient.addColorStop(1, 'rgba(255, 200, 100, 1)');
                    
                    ctx.strokeStyle = beamGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(beamStartX, beamStartY);
                    ctx.lineTo(currentEndX, currentEndY);
                    ctx.stroke();
                    
                    // draw laser beam core
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(beamStartX, beamStartY);
                    ctx.lineTo(currentEndX, currentEndY);
                    ctx.stroke();
                    
                    // draw beam tip with intense glow
                    const glowSize = 10 + Math.sin(diagramAnimationFrame * 0.3) * 3;
                    const glowGradient = ctx.createRadialGradient(currentEndX, currentEndY, 0, currentEndX, currentEndY, glowSize);
                    glowGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    glowGradient.addColorStop(0.3, 'rgba(255, 100, 100, 0.8)');
                    glowGradient.addColorStop(1, 'rgba(255, 0, 100, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(currentEndX, currentEndY, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // draw sparks at beam tip
                    if (Math.random() > 0.7) {
                        for (let i = 0; i < 3; i++) {
                            const sparkX = currentEndX + (Math.random() - 0.5) * 20;
                            const sparkY = currentEndY + (Math.random() - 0.5) * 20;
                            const sparkSize = Math.random() * 2 + 1;
                            
                            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 155}, 0, ${Math.random()})`;
                            ctx.beginPath();
                            ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // draw impact effect when beam reaches target
                    if (currentProgress > 0.95) {
                        const impactGlow = ctx.createRadialGradient(targetX, workY, 0, targetX, workY, 30);
                        impactGlow.addColorStop(0, 'rgba(255, 100, 0, 0.5)');
                        impactGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        ctx.fillStyle = impactGlow;
                        ctx.beginPath();
                        ctx.arc(targetX, workY, 30, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // cooling phase - just show impact point fading
                    const fadeProgress = (beamProgress - 0.8) / 0.2; // 0 to 1 during fade
                    const fadeOpacity = 1 - fadeProgress;
                    
                    ctx.fillStyle = `rgba(255, 100, 0, ${fadeOpacity * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(targetX, workY, 20 * (1 - fadeProgress), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // draw perpendicular line for reference
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX, workY + 30);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // draw static reference line for beam path (always visible)
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(targetX, workY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // draw angle arc
                ctx.strokeStyle = '#8a2be2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const arcRadius = 40;
                ctx.arc(centerX, centerY, arcRadius, Math.PI / 2, Math.PI / 2 + (angle * Math.PI / 180), false);
                ctx.stroke();
                
                // label angle with glow
                ctx.shadowColor = 'rgba(138, 43, 226, 0.8)';
                ctx.shadowBlur = 5;
                ctx.fillStyle = '#8a2be2';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(angle.toFixed(1) + 'Â°', centerX + 45, centerY + 20);
                ctx.shadowBlur = 0;
                
                // label distances
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '11px Arial';
                ctx.fillText(focalLength.toFixed(0) + ' mm', centerX + 5, centerY + focalLength * scale / 2);
                ctx.fillText(distance.toFixed(0) + ' mm', centerX + (targetX - centerX) / 2 - 15, workY - 5);
                
                // draw target point with pulsing effect
                const targetPulse = Math.sin(diagramAnimationFrame * 0.1) * 2 + 5;
                ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#ff6400';
                ctx.beginPath();
                ctx.arc(targetX, workY, targetPulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // draw target point highlight
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(targetX, workY, targetPulse + 2, 0, Math.PI * 2);
                ctx.stroke();
                
                // increment animation frame
                diagramAnimationFrame++;
                
                // continue animation
                diagramAnimationId = requestAnimationFrame(animateDiagram);
            }
            
            // start animation
            animateDiagram();
        }

        // calculate on page load with default values
        window.onload = function() {
            calculate();
            initParticleSystem();
            // initialize cut section with default values
            const focalLength = parseFloat(document.getElementById('focalLength').value);
            const distance = parseFloat(document.getElementById('distance')?.value || '50');
            const angleRadians = Math.atan(distance / focalLength);
            const angleDegrees = angleRadians * (180 / Math.PI);
            drawCutSection(angleDegrees, currentThickness);
            // initialize other calculators
            setTimeout(() => {
                calculateOptical();
                calculatePractical();
                loadMaterialProperties();
                drawFieldQualityMap();
            }, 100);
        };

        // tab switching
        function switchTab(tabName) {
            // hide all tabs
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // deactivate all buttons
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // activate selected button
            event.target.classList.add('active');
            
            // run tab-specific initializations
            if (tabName === 'materials') {
                // materials tab is already populated
            }
        }

        // material properties database
        const materialDatabase = {
            'mild-steel': {
                absorption: 35,
                reflectivity: 65,
                powerRange: [500, 3000],
                speedRange: [10, 100],
                maxAngle: 15,
                assistGas: 'Oxygen'
            },
            'stainless': {
                absorption: 32,
                reflectivity: 68,
                powerRange: [800, 4000],
                speedRange: [5, 50],
                maxAngle: 12,
                assistGas: 'Nitrogen'
            },
            'aluminium': {
                absorption: 8,
                reflectivity: 92,
                powerRange: [1000, 5000],
                speedRange: [20, 150],
                maxAngle: 10,
                assistGas: 'Nitrogen'
            },
            'brass': {
                absorption: 43,
                reflectivity: 57,
                powerRange: [600, 2500],
                speedRange: [8, 60],
                maxAngle: 15,
                assistGas: 'Nitrogen'
            },
            'copper': {
                absorption: 5,
                reflectivity: 95,
                powerRange: [2000, 6000],
                speedRange: [5, 30],
                maxAngle: 8,
                assistGas: 'Oxygen'
            },
            'titanium': {
                absorption: 42,
                reflectivity: 58,
                powerRange: [400, 2000],
                speedRange: [3, 20],
                maxAngle: 12,
                assistGas: 'Argon'
            },
            'acrylic': {
                absorption: 92,
                reflectivity: 8,
                powerRange: [30, 150],
                speedRange: [10, 100],
                maxAngle: 20,
                assistGas: 'Air'
            },
            'wood': {
                absorption: 85,
                reflectivity: 15,
                powerRange: [50, 500],
                speedRange: [20, 200],
                maxAngle: 25,
                assistGas: 'Air'
            },
            'abs': {
                absorption: 88,
                reflectivity: 12,
                powerRange: [40, 200],
                speedRange: [15, 120],
                maxAngle: 20,
                assistGas: 'Air'
            },
            'carbon-fiber': {
                absorption: 95,
                reflectivity: 5,
                powerRange: [200, 1000],
                speedRange: [5, 40],
                maxAngle: 10,
                assistGas: 'Nitrogen'
            }
        };

        function loadMaterialProperties() {
            const material = document.getElementById('materialType').value;
            const props = materialDatabase[material];
            
            document.getElementById('absorption').textContent = props.absorption + '%';
            document.getElementById('reflectivity').textContent = props.reflectivity + '%';
            document.getElementById('powerRange').textContent = props.powerRange[0] + '-' + props.powerRange[1] + ' W';
            document.getElementById('speedRange').textContent = props.speedRange[0] + '-' + props.speedRange[1] + ' mm/s';
            document.getElementById('maxAngle').textContent = props.maxAngle + 'Â°';
            document.getElementById('assistGas').textContent = props.assistGas;
        }

        // lens comparison

        // particle system with laser effects
        function initParticleSystem() {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            const particles = [];
            const lasers = [];
            const sparks = [];
            const maxParticles = 100;
            const maxLasers = 15;
            const maxSparks = 200;
            
            class Particle {
                constructor() {
                    this.reset();
                }
                
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 2 + 0.5;
                    this.speedX = (Math.random() - 0.5) * 0.5;
                    this.speedY = (Math.random() - 0.5) * 0.5;
                    this.opacity = Math.random() * 0.5 + 0.2;
                    this.hue = Math.random() * 60 + 260; // purple to cyan range
                }
                
                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    
                    if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
                    
                    // pulse effect
                    this.opacity += Math.sin(Date.now() * 0.001 + this.x) * 0.01;
                    this.opacity = Math.max(0.1, Math.min(0.7, this.opacity));
                }
                
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            class Laser {
                constructor() {
                    this.reset();
                }
                
                reset() {
                    this.startX = Math.random() * canvas.width;
                    this.startY = Math.random() * canvas.height;
                    this.angle = Math.random() * Math.PI * 2;
                    this.length = 0;
                    this.maxLength = Math.random() * 200 + 100;
                    this.speed = Math.random() * 5 + 5;
                    this.width = Math.random() * 2 + 1;
                    this.hue = Math.random() * 60 + 260;
                    this.growing = true;
                    this.opacity = 1;
                }
                
                update() {
                    if (this.growing) {
                        this.length += this.speed;
                        if (this.length >= this.maxLength) {
                            this.growing = false;
                        }
                    } else {
                        this.opacity -= 0.02;
                        if (this.opacity <= 0) {
                            this.reset();
                            this.opacity = 1;
                        }
                    }
                    
                    // move the laser
                    this.startX += Math.cos(this.angle) * 0.5;
                    this.startY += Math.sin(this.angle) * 0.5;
                    
                    // bounce off edges
                    if (this.startX < 0 || this.startX > canvas.width) {
                        this.angle = Math.PI - this.angle;
                        this.createSparks();
                    }
                    if (this.startY < 0 || this.startY > canvas.height) {
                        this.angle = -this.angle;
                        this.createSparks();
                    }
                    
                    // keep in bounds
                    this.startX = Math.max(0, Math.min(canvas.width, this.startX));
                    this.startY = Math.max(0, Math.min(canvas.height, this.startY));
                }
                
                createSparks() {
                    for (let i = 0; i < 5; i++) {
                        sparks.push(new Spark(
                            this.startX + Math.cos(this.angle) * this.length,
                            this.startY + Math.sin(this.angle) * this.length,
                            this.hue
                        ));
                    }
                }
                
                draw() {
                    const endX = this.startX + Math.cos(this.angle) * this.length;
                    const endY = this.startY + Math.sin(this.angle) * this.length;
                    
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    
                    // laser glow
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 50%, 0.3)`;
                    ctx.lineWidth = this.width + 10;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // laser core
                    const gradient = ctx.createLinearGradient(
                        this.startX, this.startY, endX, endY
                    );
                    gradient.addColorStop(0, `hsla(${this.hue}, 100%, 100%, 0)`);
                    gradient.addColorStop(0.1, `hsla(${this.hue}, 100%, 90%, 1)`);
                    gradient.addColorStop(0.9, `hsla(${this.hue}, 100%, 90%, 1)`);
                    gradient.addColorStop(1, `hsla(${this.hue}, 100%, 100%, 0)`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = this.width;
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // laser tip flare
                    ctx.fillStyle = `hsla(${this.hue}, 100%, 100%, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(endX, endY, this.width * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
            
            class Spark {
                constructor(x, y, hue) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() - 0.5) * 8;
                    this.size = Math.random() * 3 + 1;
                    this.life = 1;
                    this.hue = hue;
                }
                
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.98;
                    this.vy *= 0.98;
                    this.life -= 0.03;
                    this.size *= 0.98;
                }
                
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // create initial particles
            for (let i = 0; i < maxParticles; i++) {
                particles.push(new Particle());
            }
            
            // create initial lasers
            for (let i = 0; i < maxLasers; i++) {
                setTimeout(() => {
                    lasers.push(new Laser());
                }, i * 200);
            }
            
            // mouse interaction
            let mouseX = 0;
            let mouseY = 0;
            let mouseDown = false;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            document.addEventListener('mousedown', (e) => {
                // check if clicking on empty space (not on calculator)
                if (!e.target.closest('.container')) {
                    mouseDown = true;
                    // create burst of particles at mouse
                    for (let i = 0; i < 20; i++) {
                        sparks.push(new Spark(mouseX, mouseY, Math.random() * 60 + 260));
                    }
                    // create new laser from mouse position
                    if (lasers.length < maxLasers * 2) {
                        const newLaser = new Laser();
                        newLaser.startX = mouseX;
                        newLaser.startY = mouseY;
                        newLaser.angle = Math.random() * Math.PI * 2;
                        lasers.push(newLaser);
                    }
                    // limit sparks
                    if (sparks.length > maxSparks) {
                        sparks.splice(0, sparks.length - maxSparks);
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            // keyboard interaction for fun effects
            document.addEventListener('keydown', (e) => {
                // press space for laser burst
                if (e.code === 'Space' && !e.target.closest('input')) {
                    e.preventDefault();
                    // clean up old lasers if too many
                    if (lasers.length > maxLasers) {
                        lasers.splice(0, 10);
                    }
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            if (lasers.length < maxLasers * 2) {
                                const laser = new Laser();
                                laser.startX = canvas.width / 2;
                                laser.startY = canvas.height / 2;
                                laser.angle = (Math.PI * 2 / 10) * i;
                                laser.speed = 10;
                                lasers.push(laser);
                            }
                        }, i * 50);
                    }
                }
                
                // press 'p' for particle explosion
                if (e.code === 'KeyP' && !e.target.closest('input')) {
                    e.preventDefault();
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2;
                    for (let i = 0; i < 50; i++) {
                        const spark = new Spark(cx, cy, Math.random() * 360);
                        spark.vx = (Math.random() - 0.5) * 20;
                        spark.vy = (Math.random() - 0.5) * 20;
                        spark.size = Math.random() * 5 + 2;
                        sparks.push(spark);
                    }
                    // limit sparks
                    if (sparks.length > maxSparks) {
                        sparks.splice(0, sparks.length - maxSparks);
                    }
                }
            });
            
            // animation loop
            function animate() {
                ctx.fillStyle = 'rgba(15, 15, 15, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // update and draw particles
                particles.forEach(particle => {
                    particle.update();
                    
                    // attract to mouse when clicked
                    if (mouseDown) {
                        const dx = mouseX - particle.x;
                        const dy = mouseY - particle.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 200) {
                            particle.speedX += dx * 0.0001;
                            particle.speedY += dy * 0.0001;
                        }
                    }
                    
                    particle.draw();
                });
                
                // update and draw lasers
                lasers.forEach(laser => {
                    laser.update();
                    laser.draw();
                });
                
                // update and draw sparks
                for (let i = sparks.length - 1; i >= 0; i--) {
                    const spark = sparks[i];
                    spark.update();
                    spark.draw();
                    
                    if (spark.life <= 0) {
                        sparks.splice(i, 1);
                    }
                }
                
                // draw connection lines between nearby particles
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
                ctx.lineWidth = 0.5;
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 100) {
                            ctx.save();
                            ctx.globalAlpha = (1 - dist / 100) * 0.5;
                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
    </script>
</body>
</html>

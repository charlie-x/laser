<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galvo Fibre Laser Angle Calculator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        /* animated background particles */
        body::before {
            content: '';
            position: fixed;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: 
                radial-gradient(circle, rgba(138, 43, 226, 0.1) 1px, transparent 1px),
                radial-gradient(circle, rgba(0, 188, 212, 0.1) 1px, transparent 1px);
            background-size: 50px 50px, 80px 80px;
            background-position: 0 0, 40px 40px;
            animation: drift 20s linear infinite;
            z-index: -1;
        }

        @keyframes drift {
            from {
                transform: rotate(0deg) scale(1.5);
            }
            to {
                transform: rotate(360deg) scale(1.5);
            }
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .container {
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 24px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 120px rgba(138, 43, 226, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            padding: 45px;
            max-width: 650px;
            width: 100%;
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 10;
        }

        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(138, 43, 226, 0.6), 
                rgba(0, 188, 212, 0.6),
                transparent);
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% {
                opacity: 0.3;
            }
            50% {
                opacity: 1;
            }
        }

        h1 {
            color: #fff;
            margin-bottom: 10px;
            text-align: centre;
            font-size: 32px;
            font-weight: 700;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, #fff 0%, #8a2be2 50%, #00bcd4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(138, 43, 226, 0.5);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.5);
            text-align: centre;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 500;
        }

        .interaction-hint {
            text-align: centre;
            margin: 0 auto 25px auto;
            padding: 8px 16px;
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 20px;
            display: table;
            animation: pulse-hint 3s ease-in-out infinite;
        }
        
        @keyframes pulse-hint {
            0%, 100% {
                opacity: 0.6;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.02);
            }
        }

        .interaction-hint span {
            color: rgba(138, 43, 226, 0.8);
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .input-group {
            margin-bottom: 28px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        input[type="number"], select {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid rgba(138, 43, 226, 0.2);
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            backdrop-filter: blur(10px);
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #8a2be2;
            background: rgba(138, 43, 226, 0.1);
            box-shadow: 
                0 0 0 3px rgba(138, 43, 226, 0.1),
                0 0 20px rgba(138, 43, 226, 0.2);
            transform: translateY(-2px);
        }

        input[type="number"]:hover, select:hover {
            border-color: rgba(138, 43, 226, 0.4);
            background: rgba(255, 255, 255, 0.08);
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .unit {
            position: absolute;
            right: 16px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            pointer-events: none;
            font-weight: 600;
        }

        input[type="number"] {
            padding-right: 50px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }

        .preset-btn {
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(138, 43, 226, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .preset-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(138, 43, 226, 0.6);
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
        }

        .preset-btn:hover {
            border-color: #8a2be2;
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(138, 43, 226, 0.3);
        }

        .preset-btn:hover::before {
            width: 100px;
            height: 100px;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            border-color: transparent;
            color: #fff;
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
            transform: translateY(-2px);
        }

        .preset-btn.active::before {
            display: none;
        }

        .calculate-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 25px;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        .calculate-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .calculate-btn:hover::before {
            left: 100%;
        }

        .calculate-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(138, 43, 226, 0.4);
        }

        .calculate-btn:active {
            transform: translateY(-1px);
        }

        .results {
            margin-top: 35px;
            padding: 30px;
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 16px;
            display: none;
            position: relative;
            overflow: hidden;
        }

        .results::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .results.show {
            display: block;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 0;
            border-bottom: 1px solid rgba(138, 43, 226, 0.2);
            position: relative;
            z-index: 1;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .result-value {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
        }

        .result-value.highlight {
            font-size: 28px;
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% {
                filter: drop-shadow(0 0 5px rgba(138, 43, 226, 0.5));
            }
            50% {
                filter: drop-shadow(0 0 20px rgba(138, 43, 226, 0.8));
            }
        }

        .diagram {
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 12px;
            text-align: centre;
            position: relative;
            z-index: 1;
        }

        canvas {
            max-width: 100%;
            height: auto;
        }

        .info-box {
            margin-top: 25px;
            padding: 18px;
            background: rgba(255, 152, 0, 0.1);
            border-left: 4px solid #ff9800;
            border-radius: 8px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            position: relative;
            z-index: 1;
            backdrop-filter: blur(5px);
        }

        .info-box strong {
            color: #ff9800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider-container {
            margin-top: 15px;
        }

        input[type="range"] {
            width: 100%;
            margin-top: 12px;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
            transition: all 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #8a2be2 0%, #00bcd4 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
            transition: all 0.3s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
        }

        .slider-value {
            text-align: centre;
            margin-top: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
        }

        /* smooth transitions for all interactive elements */
        * {
            transition: color 0.3s, background-color 0.3s, border-color 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>
    <div class="container">
        <h1>Galvo Fibre Laser Angle Calculator</h1>
        <p class="subtitle">calculate beam incidence angle based on lens and field position</p>
        <div class="interaction-hint">
            <span>ðŸŽ® Click background for lasers â€¢ Press [Space] for burst â€¢ Press [P] for particles</span>
        </div>

        <div class="input-group">
            <label for="focalLength">Lens Focal Length</label>
            <div class="input-wrapper">
                <input type="number" id="focalLength" value="160" min="50" max="1000" step="1" oninput="calculate()">
                <span class="unit">mm</span>
            </div>
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setFocalLength(50)">50mm</button>
                <button class="preset-btn" onclick="setFocalLength(100)">100mm</button>
                <button class="preset-btn active" onclick="setFocalLength(160)">160mm</button>
                <button class="preset-btn" onclick="setFocalLength(175)">175mm</button>
                <button class="preset-btn" onclick="setFocalLength(254)">254mm</button>
                <button class="preset-btn" onclick="setFocalLength(330)">330mm</button>
                <button class="preset-btn" onclick="setFocalLength(420)">420mm</button>
            </div>
        </div>

        <div class="input-group">
            <label for="inputType">Specify Position By</label>
            <select id="inputType" onchange="toggleInputType()">
                <option value="distance">distance from centre</option>
                <option value="field">total field size</option>
                <option value="coordinates">x,y coordinates</option>
            </select>
        </div>

        <div id="distanceInput" class="input-group">
            <label for="distance">Distance from Centre</label>
            <div class="input-wrapper">
                <input type="number" id="distance" value="50" min="0" max="500" step="0.1" oninput="calculate()">
                <span class="unit">mm</span>
            </div>
        </div>

        <div id="fieldInput" class="input-group" style="display: none;">
            <label for="fieldSize">Total Field Size (Square)</label>
            <div class="input-wrapper">
                <input type="number" id="fieldSize" value="110" min="0" max="1000" step="1" oninput="calculate()">
                <span class="unit">mm</span>
            </div>
            <div class="slider-container">
                <label for="positionSlider">Position within Field (0% = centre, 100% = edge)</label>
                <input type="range" id="positionSlider" min="0" max="100" value="50" oninput="updateSliderValue(); calculate()">
                <div class="slider-value">Position: <span id="sliderValue">50</span>%</div>
            </div>
        </div>

        <div id="coordinateInput" class="input-group" style="display: none;">
            <label>Position Coordinates</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <div class="input-wrapper">
                    <input type="number" id="xCoord" value="30" min="-500" max="500" step="0.1" placeholder="X" oninput="calculate()">
                    <span class="unit">mm</span>
                </div>
                <div class="input-wrapper">
                    <input type="number" id="yCoord" value="40" min="-500" max="500" step="0.1" placeholder="Y" oninput="calculate()">
                    <span class="unit">mm</span>
                </div>
            </div>
        </div>

        <button class="calculate-btn" onclick="calculate()" style="display: none;">Recalculate</button>

        <div id="results" class="results">
            <div class="result-item">
                <span class="result-label">Beam Incidence Angle</span>
                <span class="result-value highlight" id="angleResult">0Â°</span>
            </div>
            <div class="result-item">
                <span class="result-label">Angle (radians)</span>
                <span class="result-value" id="angleRadians">0 rad</span>
            </div>
            <div class="result-item">
                <span class="result-label">Deviation from Perpendicular</span>
                <span class="result-value" id="deviation">0Â°</span>
            </div>
            <div class="result-item">
                <span class="result-label">Actual Distance from Centre</span>
                <span class="result-value" id="actualDistance">0 mm</span>
            </div>
            <div class="result-item">
                <span class="result-label">Maximum Field Size (theoretical)</span>
                <span class="result-value" id="maxField">0 mm</span>
            </div>
            
            <div class="diagram">
                <canvas id="diagram" width="400" height="300"></canvas>
            </div>

            <div class="info-box">
                <strong>note:</strong> the angle shown is the beam incidence angle relative to the perpendicular (normal) to the work surface. larger angles result in reduced cutting efficiency and potential quality issues. typical acceptable angles are below 15-20Â° for most applications.
            </div>
        </div>
    </div>

    <script>
        function setFocalLength(value) {
            document.getElementById('focalLength').value = value;
            
            // update active button state
            const buttons = document.querySelectorAll('.preset-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === value + 'mm') {
                    btn.classList.add('active');
                }
            });
            
            // trigger calculation with new focal length
            calculate();
        }

        function toggleInputType() {
            const inputType = document.getElementById('inputType').value;
            const distanceInput = document.getElementById('distanceInput');
            const fieldInput = document.getElementById('fieldInput');
            const coordinateInput = document.getElementById('coordinateInput');
            
            distanceInput.style.display = inputType === 'distance' ? 'block' : 'none';
            fieldInput.style.display = inputType === 'field' ? 'block' : 'none';
            coordinateInput.style.display = inputType === 'coordinates' ? 'block' : 'none';
            
            // recalculate with the new input type
            calculate();
        }

        function updateSliderValue() {
            const slider = document.getElementById('positionSlider');
            document.getElementById('sliderValue').textContent = slider.value;
        }

        function calculate() {
            const focalLength = parseFloat(document.getElementById('focalLength').value);
            const inputType = document.getElementById('inputType').value;
            
            let distanceFromCentre;
            
            if (inputType === 'distance') {
                distanceFromCentre = parseFloat(document.getElementById('distance').value);
            } else if (inputType === 'field') {
                const fieldSize = parseFloat(document.getElementById('fieldSize').value);
                const position = parseFloat(document.getElementById('positionSlider').value) / 100;
                distanceFromCentre = (fieldSize / 2) * position;
            } else if (inputType === 'coordinates') {
                const x = parseFloat(document.getElementById('xCoord').value);
                const y = parseFloat(document.getElementById('yCoord').value);
                distanceFromCentre = Math.sqrt(x * x + y * y);
            }
            
            // calculate angle using arctangent
            // angle = arctan(distance_from_centre / focal_length)
            const angleRadians = Math.atan(distanceFromCentre / focalLength);
            const angleDegrees = angleRadians * (180 / Math.PI);
            
            // calculate theoretical maximum field size (typically limited to about 70% for quality)
            const maxFieldTheoretical = focalLength * 2 * Math.tan(70 * Math.PI / 180);
            
            // display results
            document.getElementById('angleResult').textContent = angleDegrees.toFixed(2) + 'Â°';
            document.getElementById('angleRadians').textContent = angleRadians.toFixed(4) + ' rad';
            document.getElementById('deviation').textContent = angleDegrees.toFixed(2) + 'Â°';
            document.getElementById('actualDistance').textContent = distanceFromCentre.toFixed(1) + ' mm';
            document.getElementById('maxField').textContent = maxFieldTheoretical.toFixed(0) + ' mm';
            
            // show results section
            document.getElementById('results').classList.add('show');
            
            // draw diagram
            drawDiagram(focalLength, distanceFromCentre, angleDegrees);
        }

        // animation state for diagram laser
        let diagramAnimationFrame = 0;
        let diagramAnimationId = null;
        
        function drawDiagram(focalLength, distance, angle) {
            const canvas = document.getElementById('diagram');
            const ctx = canvas.getContext('2d');
            
            // cancel previous animation if running
            if (diagramAnimationId) {
                cancelAnimationFrame(diagramAnimationId);
            }
            
            const centerX = canvas.width / 2;
            const centerY = 50;
            const scale = Math.min(200 / focalLength, 2);
            const workY = centerY + focalLength * scale;
            const targetX = centerX + distance * scale;
            
            // reset animation frame
            diagramAnimationFrame = 0;
            
            function animateDiagram() {
                // clear canvas
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // draw glow effect for lens
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 30);
                gradient.addColorStop(0, 'rgba(138, 43, 226, 0.3)');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // draw lens with pulsing effect
                const lensPulse = Math.sin(diagramAnimationFrame * 0.05) * 2 + 20;
                ctx.strokeStyle = '#8a2be2';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, lensPulse, 0, Math.PI * 2);
                ctx.stroke();
                
                // lens highlight
                ctx.strokeStyle = '#00bcd4';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, lensPulse + 2, -Math.PI / 4, Math.PI / 4);
                ctx.stroke();
                
                ctx.fillStyle = '#8a2be2';
                ctx.font = '12px Arial';
                ctx.fillText('lens', centerX - 15, centerY - 25);
                
                // draw work surface with glow
                ctx.shadowColor = 'rgba(0, 188, 212, 0.5)';
                ctx.shadowBlur = 10;
                ctx.strokeStyle = '#00bcd4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(30, workY);
                ctx.lineTo(canvas.width - 30, workY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#00bcd4';
                ctx.font = '12px Arial';
                ctx.fillText('work surface', 30, workY + 20);
                
                // calculate laser beam animation progress (0 to 1, then reset)
                const beamCycle = 150; // frames for one complete beam
                const beamProgress = (diagramAnimationFrame % beamCycle) / beamCycle;
                
                // draw animated laser beam
                if (beamProgress < 0.8) { // beam firing phase (80% of cycle)
                    const currentProgress = beamProgress / 0.8; // normalise to 0-1
                    
                    // calculate current beam endpoint
                    const currentEndX = centerX + (targetX - centerX) * currentProgress;
                    const currentEndY = centerY + (workY - centerY) * currentProgress;
                    
                    // draw laser beam trail with fading effect
                    for (let i = 0; i < 5; i++) {
                        const trailProgress = Math.max(0, currentProgress - i * 0.02);
                        if (trailProgress > 0) {
                            const trailEndX = centerX + (targetX - centerX) * trailProgress;
                            const trailEndY = centerY + (workY - centerY) * trailProgress;
                            const trailStartProgress = Math.max(0, trailProgress - 0.1);
                            const trailStartX = centerX + (targetX - centerX) * trailStartProgress;
                            const trailStartY = centerY + (workY - centerY) * trailStartProgress;
                            
                            ctx.strokeStyle = `rgba(255, 0, 100, ${0.2 - i * 0.03})`;
                            ctx.lineWidth = 8 - i;
                            ctx.beginPath();
                            ctx.moveTo(trailStartX, trailStartY);
                            ctx.lineTo(trailEndX, trailEndY);
                            ctx.stroke();
                        }
                    }
                    
                    // draw main laser beam with gradient
                    const beamStartProgress = Math.max(0, currentProgress - 0.1);
                    const beamStartX = centerX + (targetX - centerX) * beamStartProgress;
                    const beamStartY = centerY + (workY - centerY) * beamStartProgress;
                    
                    const beamGradient = ctx.createLinearGradient(beamStartX, beamStartY, currentEndX, currentEndY);
                    beamGradient.addColorStop(0, 'rgba(255, 100, 200, 0.2)');
                    beamGradient.addColorStop(0.5, 'rgba(255, 0, 100, 1)');
                    beamGradient.addColorStop(1, 'rgba(255, 200, 100, 1)');
                    
                    ctx.strokeStyle = beamGradient;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(beamStartX, beamStartY);
                    ctx.lineTo(currentEndX, currentEndY);
                    ctx.stroke();
                    
                    // draw laser beam core
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(beamStartX, beamStartY);
                    ctx.lineTo(currentEndX, currentEndY);
                    ctx.stroke();
                    
                    // draw beam tip with intense glow
                    const glowSize = 10 + Math.sin(diagramAnimationFrame * 0.3) * 3;
                    const glowGradient = ctx.createRadialGradient(currentEndX, currentEndY, 0, currentEndX, currentEndY, glowSize);
                    glowGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    glowGradient.addColorStop(0.3, 'rgba(255, 100, 100, 0.8)');
                    glowGradient.addColorStop(1, 'rgba(255, 0, 100, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(currentEndX, currentEndY, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // draw sparks at beam tip
                    if (Math.random() > 0.7) {
                        for (let i = 0; i < 3; i++) {
                            const sparkX = currentEndX + (Math.random() - 0.5) * 20;
                            const sparkY = currentEndY + (Math.random() - 0.5) * 20;
                            const sparkSize = Math.random() * 2 + 1;
                            
                            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 155}, 0, ${Math.random()})`;
                            ctx.beginPath();
                            ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // draw impact effect when beam reaches target
                    if (currentProgress > 0.95) {
                        const impactGlow = ctx.createRadialGradient(targetX, workY, 0, targetX, workY, 30);
                        impactGlow.addColorStop(0, 'rgba(255, 100, 0, 0.5)');
                        impactGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        ctx.fillStyle = impactGlow;
                        ctx.beginPath();
                        ctx.arc(targetX, workY, 30, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // cooling phase - just show impact point fading
                    const fadeProgress = (beamProgress - 0.8) / 0.2; // 0 to 1 during fade
                    const fadeOpacity = 1 - fadeProgress;
                    
                    ctx.fillStyle = `rgba(255, 100, 0, ${fadeOpacity * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(targetX, workY, 20 * (1 - fadeProgress), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // draw perpendicular line for reference
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX, workY + 30);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // draw static reference line for beam path (always visible)
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(targetX, workY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // draw angle arc
                ctx.strokeStyle = '#8a2be2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const arcRadius = 40;
                ctx.arc(centerX, centerY, arcRadius, Math.PI / 2, Math.PI / 2 + (angle * Math.PI / 180), false);
                ctx.stroke();
                
                // label angle with glow
                ctx.shadowColor = 'rgba(138, 43, 226, 0.8)';
                ctx.shadowBlur = 5;
                ctx.fillStyle = '#8a2be2';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(angle.toFixed(1) + 'Â°', centerX + 45, centerY + 20);
                ctx.shadowBlur = 0;
                
                // label distances
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '11px Arial';
                ctx.fillText(focalLength.toFixed(0) + ' mm', centerX + 5, centerY + focalLength * scale / 2);
                ctx.fillText(distance.toFixed(0) + ' mm', centerX + (targetX - centerX) / 2 - 15, workY - 5);
                
                // draw target point with pulsing effect
                const targetPulse = Math.sin(diagramAnimationFrame * 0.1) * 2 + 5;
                ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#ff6400';
                ctx.beginPath();
                ctx.arc(targetX, workY, targetPulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // draw target point highlight
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(targetX, workY, targetPulse + 2, 0, Math.PI * 2);
                ctx.stroke();
                
                // increment animation frame
                diagramAnimationFrame++;
                
                // continue animation
                diagramAnimationId = requestAnimationFrame(animateDiagram);
            }
            
            // start animation
            animateDiagram();
        }

        // calculate on page load with default values
        window.onload = function() {
            calculate();
            initParticleSystem();
        };

        // particle system with laser effects
        function initParticleSystem() {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            const particles = [];
            const lasers = [];
            const sparks = [];
            const maxParticles = 100;
            const maxLasers = 15;
            const maxSparks = 200;
            
            class Particle {
                constructor() {
                    this.reset();
                }
                
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 2 + 0.5;
                    this.speedX = (Math.random() - 0.5) * 0.5;
                    this.speedY = (Math.random() - 0.5) * 0.5;
                    this.opacity = Math.random() * 0.5 + 0.2;
                    this.hue = Math.random() * 60 + 260; // purple to cyan range
                }
                
                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    
                    if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
                    
                    // pulse effect
                    this.opacity += Math.sin(Date.now() * 0.001 + this.x) * 0.01;
                    this.opacity = Math.max(0.1, Math.min(0.7, this.opacity));
                }
                
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            class Laser {
                constructor() {
                    this.reset();
                }
                
                reset() {
                    this.startX = Math.random() * canvas.width;
                    this.startY = Math.random() * canvas.height;
                    this.angle = Math.random() * Math.PI * 2;
                    this.length = 0;
                    this.maxLength = Math.random() * 200 + 100;
                    this.speed = Math.random() * 5 + 5;
                    this.width = Math.random() * 2 + 1;
                    this.hue = Math.random() * 60 + 260;
                    this.growing = true;
                    this.opacity = 1;
                }
                
                update() {
                    if (this.growing) {
                        this.length += this.speed;
                        if (this.length >= this.maxLength) {
                            this.growing = false;
                        }
                    } else {
                        this.opacity -= 0.02;
                        if (this.opacity <= 0) {
                            this.reset();
                            this.opacity = 1;
                        }
                    }
                    
                    // move the laser
                    this.startX += Math.cos(this.angle) * 0.5;
                    this.startY += Math.sin(this.angle) * 0.5;
                    
                    // bounce off edges
                    if (this.startX < 0 || this.startX > canvas.width) {
                        this.angle = Math.PI - this.angle;
                        this.createSparks();
                    }
                    if (this.startY < 0 || this.startY > canvas.height) {
                        this.angle = -this.angle;
                        this.createSparks();
                    }
                    
                    // keep in bounds
                    this.startX = Math.max(0, Math.min(canvas.width, this.startX));
                    this.startY = Math.max(0, Math.min(canvas.height, this.startY));
                }
                
                createSparks() {
                    for (let i = 0; i < 5; i++) {
                        sparks.push(new Spark(
                            this.startX + Math.cos(this.angle) * this.length,
                            this.startY + Math.sin(this.angle) * this.length,
                            this.hue
                        ));
                    }
                }
                
                draw() {
                    const endX = this.startX + Math.cos(this.angle) * this.length;
                    const endY = this.startY + Math.sin(this.angle) * this.length;
                    
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    
                    // laser glow
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 50%, 0.3)`;
                    ctx.lineWidth = this.width + 10;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // laser core
                    const gradient = ctx.createLinearGradient(
                        this.startX, this.startY, endX, endY
                    );
                    gradient.addColorStop(0, `hsla(${this.hue}, 100%, 100%, 0)`);
                    gradient.addColorStop(0.1, `hsla(${this.hue}, 100%, 90%, 1)`);
                    gradient.addColorStop(0.9, `hsla(${this.hue}, 100%, 90%, 1)`);
                    gradient.addColorStop(1, `hsla(${this.hue}, 100%, 100%, 0)`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = this.width;
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // laser tip flare
                    ctx.fillStyle = `hsla(${this.hue}, 100%, 100%, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(endX, endY, this.width * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }
            
            class Spark {
                constructor(x, y, hue) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = (Math.random() - 0.5) * 8;
                    this.size = Math.random() * 3 + 1;
                    this.life = 1;
                    this.hue = hue;
                }
                
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.98;
                    this.vy *= 0.98;
                    this.life -= 0.03;
                    this.size *= 0.98;
                }
                
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // create initial particles
            for (let i = 0; i < maxParticles; i++) {
                particles.push(new Particle());
            }
            
            // create initial lasers
            for (let i = 0; i < maxLasers; i++) {
                setTimeout(() => {
                    lasers.push(new Laser());
                }, i * 200);
            }
            
            // mouse interaction
            let mouseX = 0;
            let mouseY = 0;
            let mouseDown = false;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            document.addEventListener('mousedown', (e) => {
                // check if clicking on empty space (not on calculator)
                if (!e.target.closest('.container')) {
                    mouseDown = true;
                    // create burst of particles at mouse
                    for (let i = 0; i < 20; i++) {
                        sparks.push(new Spark(mouseX, mouseY, Math.random() * 60 + 260));
                    }
                    // create new laser from mouse position
                    if (lasers.length < maxLasers * 2) {
                        const newLaser = new Laser();
                        newLaser.startX = mouseX;
                        newLaser.startY = mouseY;
                        newLaser.angle = Math.random() * Math.PI * 2;
                        lasers.push(newLaser);
                    }
                    // limit sparks
                    if (sparks.length > maxSparks) {
                        sparks.splice(0, sparks.length - maxSparks);
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            // keyboard interaction for fun effects
            document.addEventListener('keydown', (e) => {
                // press space for laser burst
                if (e.code === 'Space' && !e.target.closest('input')) {
                    e.preventDefault();
                    // clean up old lasers if too many
                    if (lasers.length > maxLasers) {
                        lasers.splice(0, 10);
                    }
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            if (lasers.length < maxLasers * 2) {
                                const laser = new Laser();
                                laser.startX = canvas.width / 2;
                                laser.startY = canvas.height / 2;
                                laser.angle = (Math.PI * 2 / 10) * i;
                                laser.speed = 10;
                                lasers.push(laser);
                            }
                        }, i * 50);
                    }
                }
                
                // press 'p' for particle explosion
                if (e.code === 'KeyP' && !e.target.closest('input')) {
                    e.preventDefault();
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2;
                    for (let i = 0; i < 50; i++) {
                        const spark = new Spark(cx, cy, Math.random() * 360);
                        spark.vx = (Math.random() - 0.5) * 20;
                        spark.vy = (Math.random() - 0.5) * 20;
                        spark.size = Math.random() * 5 + 2;
                        sparks.push(spark);
                    }
                    // limit sparks
                    if (sparks.length > maxSparks) {
                        sparks.splice(0, sparks.length - maxSparks);
                    }
                }
            });
            
            // animation loop
            function animate() {
                ctx.fillStyle = 'rgba(15, 15, 15, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // update and draw particles
                particles.forEach(particle => {
                    particle.update();
                    
                    // attract to mouse when clicked
                    if (mouseDown) {
                        const dx = mouseX - particle.x;
                        const dy = mouseY - particle.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 200) {
                            particle.speedX += dx * 0.0001;
                            particle.speedY += dy * 0.0001;
                        }
                    }
                    
                    particle.draw();
                });
                
                // update and draw lasers
                lasers.forEach(laser => {
                    laser.update();
                    laser.draw();
                });
                
                // update and draw sparks
                for (let i = sparks.length - 1; i >= 0; i--) {
                    const spark = sparks[i];
                    spark.update();
                    spark.draw();
                    
                    if (spark.life <= 0) {
                        sparks.splice(i, 1);
                    }
                }
                
                // draw connection lines between nearby particles
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
                ctx.lineWidth = 0.5;
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 100) {
                            ctx.save();
                            ctx.globalAlpha = (1 - dist / 100) * 0.5;
                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
    </script>
</body>
</html>
